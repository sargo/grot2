// Generated by CoffeeScript 1.10.0
(function() {
  var Engine, Game, QueryString, RenderManager, arrow, arrowCommands, drawArrow, game, smallArrow,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.cfg = {

    /*
    Board size
     */
    defaultBoardSize: 5,
    baseScale: 1,
    baseWindowSize: {
      width: 1600,
      height: 900
    },

    /*
    Enables or disables possibility to pass
    initial board size as ?size=x param
     */
    customBoardSize: false,

    /*
    Display row with fields that will replace empty fields after move
     */
    showPreview: true,

    /*
    Enables or disables possibility to pass
    ?preview=yes param to enable preview
     */
    customShowPreview: false,

    /*
    FieldWidget(Circle) settings
     */
    circleColor1: '#868788',
    circleColor2: '#ffec00',
    circleColor3: '#8d198f',
    circleColor4: '#00968f',
    circleRadius: 65,
    spaceBetweenFields: 16,
    previewHeight: 80,
    previewCircleRadius: 32,
    spaceBetweenPreviewFields: 8,

    /*
    Arrow settings
     */
    arrowColor: '#ffffff',

    /*
    Tween duration settings
    
    Enables or disables possibility to pass
    ?speed=1..9 param to configure animation speed
     */
    customSpeed: true,
    defaultSpeed: 6,
    tweenDurationUnit: 0.1,

    /*
    Font settings
     */
    fontScoMovColor: '#868788',
    fontScoMovNumColor: '#00968f',
    fontMenuColor: '#ffffff',
    fontFamily: 'Lato',
    fontScoMovSize: 46,
    fontRestSize: 38,
    fontStyle: 'Bold',

    /*
    Background color settings
     */
    bodyColor: '#ffffff',
    overlayColor: '#333333',
    overlayBodyColor: '#484848',

    /*
    Urls settings
     */
    scoreBoardLink: 'http://game.pythonfasterway.org/hall-of-fame/',

    /*
    Help description
     */
    helpDesc: ' This logic game is about making the most\n valuable chains possible!\n\n Tap or click any field to start a chain\n reaction - fields will move one by one in\n the direction shown by the arrowheads.\n\n Longer chains grant move bonuses.\n Clear all fields in a row or in a column\n to get extra points.\n\n Collect as many points as possible!',

    /*
    About description
     */
    aboutDesc: ' Source code\n https://github.com/sargo/grot2',
    aboutVer: ' v2.0'
  };


  /*
  Game engine.
  
  Here we store all abstract classes of which
  will be used by game to draw stage, layers etc.
   */

  Engine = (function() {
    function Engine() {
      var cfg, engine;
      engine = this;
      cfg = window.cfg;

      /*
      Widget class
      
      This class is inherited by every widged used across the game.
      By widgets we understand any objects made from one ore more
      groups of objects (Shapes, Labels etc.)
       */
      this.Widget = (function(superClass) {
        extend(Widget, superClass);

        Widget.prototype.margins = null;

        Widget.prototype.currentScale = null;

        Widget.prototype.layer = null;

        function Widget(config) {
          var field;
          for (field in config) {
            if (typeof this[field] !== 'undefined' && typeof this[field] !== 'function') {
              this[field] = config[field];
            }
          }
          if (!config.margins) {
            this.margins = {
              x: 0,
              y: 0
            };
          }
          Widget.__super__.constructor.apply(this, arguments);
          this.on('update', this.updateHandler);
        }

        Widget.prototype.getCurrentX = function() {
          return this.margins.x * this.currentScale;
        };

        Widget.prototype.getCurrentY = function() {
          return this.margins.y * this.currentScale;
        };

        Widget.prototype.rePosition = function() {
          this.x(this.getCurrentX());
          this.y(this.getCurrentY());
          return [this.x(), this.y()];
        };

        Widget.prototype.updateHandler = function(event) {
          if (this.layer) {
            this.currentScale = this.layer.currentScale;
            return this.rePosition();
          }
        };

        Widget.prototype.scale = function(scale) {
          if (this.group != null) {
            return this.group.scale({
              x: scale,
              y: scale
            });
          } else {
            scale = {
              x: scale,
              y: scale
            };
            return Widget.__super__.scale.apply(this, arguments);
          }
        };

        Widget.prototype.centerElement = function(element) {
          element.offsetX(element.width() / 2);
          return element.offsetY(element.height() / 2);
        };

        return Widget;

      })(Kinetic.Group);

      /*
      Layer class
      
      This class is inherited by every layer used across the game.
      By layers we understand spearate canvases generated on the page
      that can contain multiple widgets, groups, shapes ect.
       */
      this.Layer = (function(superClass) {
        extend(Layer, superClass);

        Layer.prototype.renderManager = null;

        Layer.prototype.currentScale = null;

        Layer.prototype.margins = null;

        function Layer(config) {
          var field;
          for (field in config) {
            if (typeof this[field] !== 'undefined' && typeof this[field] !== 'function') {
              this[field] = config[field];
            }
          }
          Layer.__super__.constructor.apply(this, arguments);
          if (!config.margins) {
            this.margins = {
              x: 0,
              y: 0
            };
          }
        }

        Layer.prototype.updateHandler = function(event) {
          var height, width;
          this.currentScale = this.renderManager.currentScale;
          this.scale({
            x: this.currentScale,
            y: this.currentScale
          });
          this.rePosition();
          width = ((this.getWidth() * this.currentScale) || this.parent.getWidth()) + this.getCurrentX();
          height = ((this.getHeight() * this.currentScale) || this.parent.getHeight()) + this.getCurrentY();
          this.canvas.setSize(width, height);
          return this.batchDraw();
        };

        Layer.prototype.getCurrentX = function() {
          var precentage;
          if (typeof this.margins.x === 'number') {
            return this.margins.x * this.currentScale;
          } else {
            precentage = (this.margins.x.match(/\d+/) || [0])[0] / 100;
            return (this.parent.getWidth() - this.getWidth() * this.currentScale) * precentage;
          }
        };

        Layer.prototype.getCurrentY = function() {
          var precentage;
          if (typeof this.margins.y === 'number') {
            return this.margins.y * this.currentScale;
          } else {
            precentage = (this.margins.x.match(/\d+/) || [0])[0] / 100;
            return (this.parent.getHeight() - this.getHeight() * this.currentScale) * precentage;
          }
        };

        Layer.prototype.rePosition = function() {
          this.x(this.getCurrentX());
          this.y(this.getCurrentY());
          return [this.x(), this.y()];
        };

        return Layer;

      })(Kinetic.Layer);

      /*
      RenderManager class
      
      This class contains all basic logic necessary for rendering layers
      and keeping them up to date. HIt is heart of the game.
       */
      this.RenderManager = (function() {
        RenderManager.prototype.cfg = cfg;

        RenderManager.prototype.baseScale = cfg.baseScale != null ? cfg.baseScale : 1;

        RenderManager.prototype.baseWindowSize = cfg.baseWindowSize != null ? cfg.baseWindowSize : null;

        RenderManager.prototype.currentScale = null;

        RenderManager.prototype.stage = null;

        RenderManager.prototype.showPreview = false;

        function RenderManager() {
          var height, j, layer, layers, len, ref, width;
          if (this.baseWindowSize == null) {
            ref = this.getWindowSize(), width = ref[0], height = ref[1];
            this.baseWindowSize = {
              width: width,
              height: height
            };
          }
          if (this.currentScale == null) {
            this.currentScale = this.calculateScaleUnit();
          }
          layers = this.stage.getLayers();
          for (j = 0, len = layers.length; j < len; j++) {
            layer = layers[j];
            layer.on('update', layer.updateHandler);
            layer.fire('update');
          }
          this.updateMargin();
        }

        RenderManager.prototype.getWindowSize = function() {
          return [window.innerWidth, window.innerHeight];
        };

        RenderManager.prototype.calculateScaleUnit = function() {
          var height, maxHeight, maxWidth, previewHeight, ratio, ref, scale, scaleXValue, scaleYValue, width;
          ref = this.getWindowSize(), maxWidth = ref[0], maxHeight = ref[1];
          previewHeight = this.showPreview ? cfg.previewHeight : 0;
          width = 600;
          height = 900 + previewHeight;
          if (height > maxHeight) {
            ratio = maxHeight / height;
            height = maxHeight;
            width = width * ratio;
          }
          if (width > maxWidth) {
            ratio = maxWidth / width;
            width = maxWidth;
            height = height * ratio;
          }
          scaleXValue = width / 600;
          scaleYValue = height / (900 + previewHeight);
          scale = Math.min(scaleXValue, scaleYValue);
          return Number(scale.toFixed(2));
        };

        RenderManager.prototype.updateMargin = function() {
          var j, layer, layers, len, marginWidth, maxWidth;
          maxWidth = 0;
          layers = this.stage.getLayers();
          for (j = 0, len = layers.length; j < len; j++) {
            layer = layers[j];
            maxWidth = Math.max(maxWidth, layer.canvas.width / layer.canvas.getPixelRatio());
          }
          marginWidth = Math.ceil((this.getWindowSize()[0] - maxWidth) / 2);
          marginWidth = Math.max(marginWidth, 0);
          return this.stage.getContainer().style.marginLeft = marginWidth + 'px';
        };

        RenderManager.prototype.centerLayer = function(layer) {
          return layer.offsetX(-(this.stage.getWidth() - layer.getWidth()) / 2);
        };

        RenderManager.prototype.adaptStage = function() {
          var height, ref, width;
          ref = this.getWindowSize(), width = ref[0], height = ref[1];
          this.stage.setHeight(height);
          return this.stage.setWidth(width);
        };

        RenderManager.prototype.update = function() {
          var j, layer, layers, len;
          this.currentScale = this.calculateScaleUnit();
          this.adaptStage();
          layers = this.stage.getLayers();
          for (j = 0, len = layers.length; j < len; j++) {
            layer = layers[j];
            layer.fire('update');
          }
          this.stage.fire('onStageUpdated');
          return this.updateMargin();
        };

        return RenderManager;

      })();
      this.Game = (function() {
        function Game() {
          window.onresize = this.update.bind(this);
          if (!!window.ondeviceorientation) {
            window.ondeviceorientation = this.update.bind(this);
          }
        }

        Game.prototype.update = function() {
          return this.renderManager.update.call(this.renderManager);
        };

        return Game;

      })();
    }

    return Engine;

  })();

  window.GrotEngine = new Engine;

  window.Grot = {};

  arrowCommands = [
    {
      y: -12.40625,
      x: -3.38671875,
      type: 'M'
    }, {
      y1: -8.94921875,
      x: -9.71484375,
      x1: -6.521484375,
      type: 'Q',
      y: -5.4921875
    }, {
      y1: -2.03515625,
      x: -16.365234375,
      x1: -12.908203125,
      type: 'Q',
      y: 1.392578125
    }, {
      y1: 1.626953125,
      x: -16.8779296875,
      x1: -16.599609375,
      type: 'Q',
      y: 1.7294921875
    }, {
      y1: 1.83203125,
      x: -17.5517578125,
      x1: -17.15625,
      type: 'Q',
      y: 1.685546875
    }, {
      y1: 1.5390625,
      x: -18.50390625,
      x1: -17.947265625,
      type: 'Q',
      y: 1.1142578125
    }, {
      y1: 0.689453125,
      x: -19.880859375,
      x1: -19.060546875,
      type: 'Q',
      y: -0.130859375
    }, {
      y1: -0.921875,
      x: -21.0380859375,
      x1: -20.642578125,
      type: 'Q',
      y: -1.44921875
    }, {
      y1: -1.9765625,
      x: -21.55078125,
      x1: -21.43359375,
      type: 'Q',
      y: -2.3427734375
    }, {
      y1: -2.708984375,
      x: -21.580078125,
      x1: -21.66796875,
      type: 'Q',
      y: -2.97265625
    }, {
      y1: -3.236328125,
      x: -21.2578125,
      x1: -21.4921875,
      type: 'Q',
      y: -3.470703125
    }, {
      y: -22.748046875,
      x: -1.98046875,
      type: 'L'
    }, {
      y1: -23.1875,
      x: -1.04296875,
      x1: -1.541015625,
      type: 'Q',
      y: -23.48046875
    }, {
      y1: -23.7734375,
      x: 0.158203125,
      x1: -0.544921875,
      type: 'Q',
      y: -23.7734375
    }, {
      y1: -23.7734375,
      x: 1.30078125,
      x1: 0.802734375,
      type: 'Q',
      y: -23.509765625
    }, {
      y1: -23.24609375,
      x: 2.296875,
      x1: 1.798828125,
      type: 'Q',
      y: -22.748046875
    }, {
      y: -3.470703125,
      x: 21.57421875,
      type: 'L'
    }, {
      y1: -3.236328125,
      x: 21.8818359375,
      x1: 21.779296875,
      type: 'Q',
      y: -2.97265625
    }, {
      y1: -2.708984375,
      x: 21.8671875,
      x1: 21.984375,
      type: 'Q',
      y: -2.3427734375
    }, {
      y1: -1.9765625,
      x: 21.3544921875,
      x1: 21.75,
      type: 'Q',
      y: -1.44921875
    }, {
      y1: -0.921875,
      x: 20.197265625,
      x1: 20.958984375,
      type: 'Q',
      y: -0.130859375
    }, {
      y1: 0.689453125,
      x: 18.8203125,
      x1: 19.376953125,
      type: 'Q',
      y: 1.1142578125
    }, {
      y1: 1.5390625,
      x: 17.8681640625,
      x1: 18.263671875,
      type: 'Q',
      y: 1.685546875
    }, {
      y1: 1.83203125,
      x: 17.1943359375,
      x1: 17.47265625,
      type: 'Q',
      y: 1.7294921875
    }, {
      y1: 1.626953125,
      x: 16.681640625,
      x1: 16.916015625,
      type: 'Q',
      y: 1.392578125
    }, {
      y1: -2.03515625,
      x: 10.03125,
      x1: 13.224609375,
      type: 'Q',
      y: -5.4921875
    }, {
      y1: -8.94921875,
      x: 3.703125,
      x1: 6.837890625,
      type: 'Q',
      y: -12.40625
    }, {
      y: 24.771484375,
      x: 3.703125,
      type: 'L'
    }, {
      y1: 25.005859375,
      x: 3.52734375,
      x1: 3.703125,
      type: 'Q',
      y: 25.2109375
    }, {
      y1: 25.416015625,
      x: 2.9560546875,
      x1: 3.3515625,
      type: 'Q',
      y: 25.5625
    }, {
      y1: 25.708984375,
      x: 1.8720703125,
      x1: 2.560546875,
      type: 'Q',
      y: 25.796875
    }, {
      y1: 25.884765625,
      x: 0.158203125,
      x1: 1.18359375,
      type: 'Q',
      y: 25.884765625
    }, {
      y1: 25.884765625,
      x: -1.5556640625,
      x1: -0.8671875,
      type: 'Q',
      y: 25.796875
    }, {
      y1: 25.708984375,
      x: -2.6396484375,
      x1: -2.244140625,
      type: 'Q',
      y: 25.5625
    }, {
      y1: 25.416015625,
      x: -3.2109375,
      x1: -3.03515625,
      type: 'Q',
      y: 25.2109375
    }, {
      y1: 25.005859375,
      x: -3.38671875,
      x1: -3.38671875,
      type: 'Q',
      y: 24.771484375
    }, {
      y: -12.40625,
      x: -3.38671875,
      type: 'L'
    }, {
      type: 'Z'
    }
  ];

  drawArrow = function(ctx, scale) {
    var cmd, i, results, s;
    s = scale;
    ctx.beginPath();
    i = 0;
    results = [];
    while (i < arrowCommands.length) {
      cmd = arrowCommands[i];
      if (cmd.type === 'M') {
        ctx.moveTo(cmd.x * s, cmd.y * s);
      } else if (cmd.type === 'L') {
        ctx.lineTo(cmd.x * s, cmd.y * s);
      } else if (cmd.type === 'C') {
        ctx.bezierCurveTo(cmd.x1 * s, cmd.y1 * s, cmd.x2 * s, cmd.y2 * s, cmd.x * s, cmd.y * s);
      } else if (cmd.type === 'Q') {
        ctx.quadraticCurveTo(cmd.x1 * s, cmd.y1 * s, cmd.x * s, cmd.y * s);
      } else if (cmd.type === 'Z') {
        ctx.closePath();
      }
      results.push(i += 1);
    }
    return results;
  };

  arrow = new Kinetic.Shape({
    sceneFunc: function(ctx) {
      drawArrow(ctx, 1.5);
      return ctx.fillStrokeShape(this);
    },
    fill: cfg.arrowColor
  });

  smallArrow = new Kinetic.Shape({
    sceneFunc: function(ctx) {
      drawArrow(ctx, 0.75);
      return ctx.fillStrokeShape(this);
    },
    fill: cfg.arrowColor
  });

  Grot.TopBarWidget = (function(superClass) {
    extend(TopBarWidget, superClass);

    TopBarWidget.prototype.game = null;

    TopBarWidget.prototype.scoreLabel = null;

    TopBarWidget.prototype.score = null;

    TopBarWidget.prototype.movesLabel = null;

    TopBarWidget.prototype.moves = null;

    TopBarWidget.prototype.showPreview = false;

    function TopBarWidget(config) {
      this.delayAnim = bind(this.delayAnim, this);
      var line;
      TopBarWidget.__super__.constructor.apply(this, arguments);
      this.background = new Kinetic.Rect({
        width: 600,
        height: 180,
        fill: cfg.bodyColor
      });
      this.add(this.background);
      this.scoreLabel = new Kinetic.Text({
        x: 155,
        y: 50,
        text: 'Score',
        align: 'center',
        fontSize: cfg.fontRestSize,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontScoMovColor
      });
      this.score = new Kinetic.Text({
        x: 150,
        y: 100,
        text: this.game.score,
        align: 'center',
        fontSize: cfg.fontScoMovSize,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontScoMovNumColor
      });
      this.scoreDiff = new Kinetic.Text({
        x: 150,
        y: 150,
        text: '',
        align: 'center',
        fontSize: cfg.fontRestSize,
        fontFamily: cfg.fontFamily,
        fill: cfg.fontScoMovNumColor
      });
      this.movesLabel = new Kinetic.Text({
        x: 455,
        y: 50,
        text: 'Moves',
        align: 'center',
        fontSize: cfg.fontRestSize,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontScoMovColor
      });
      this.moves = new Kinetic.Text({
        x: 450,
        y: 100,
        text: this.game.moves,
        align: 'center',
        fontSize: cfg.fontScoMovSize,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontScoMovNumColor
      });
      this.movesDiff = new Kinetic.Text({
        x: 450,
        y: 150,
        text: '',
        align: 'center',
        fontSize: cfg.fontRestSize,
        fontFamily: cfg.fontFamily,
        fill: cfg.fontScoMovNumColor
      });
      line = new Kinetic.Rect({
        x: 0,
        y: 180,
        width: 600,
        height: 2,
        fill: cfg.fontScoMovNumColor
      });
      this.centerElement(this.scoreLabel);
      this.centerElement(this.score);
      this.centerElement(this.scoreDiff);
      this.centerElement(this.movesLabel);
      this.centerElement(this.moves);
      this.centerElement(this.movesDiff);
      this.add(this.scoreLabel);
      this.add(this.score);
      this.add(this.scoreDiff);
      this.add(this.movesLabel);
      this.add(this.moves);
      this.add(this.movesDiff);
      this.add(line);
    }

    TopBarWidget.prototype.delayAnim = function(diff) {
      return delay1s((function(_this) {
        return function() {
          var tween;
          tween = new Kinetic.Tween({
            node: diff,
            opacity: 0,
            duration: window.TWEEN_DURATION,
            onFinish: function() {
              return this.destroy();
            }
          });
          return tween.play();
        };
      })(this));
    };

    TopBarWidget.prototype.update = function() {
      this.score.setText(this.game.score);
      if (this.game.scoreDiff === 0) {
        this.scoreDiff.setText(' ');
      } else {
        this.scoreDiff.setText('+' + this.game.scoreDiff);
        this.scoreDiff.opacity(1);
        this.delayAnim(this.scoreDiff);
      }
      this.moves.setText(this.game.moves);
      if (this.game.movesDiff === 0) {
        this.movesDiff.setText(' ');
      } else {
        this.movesDiff.setText('+' + this.game.movesDiff);
        this.movesDiff.opacity(1);
        this.delayAnim(this.movesDiff);
      }
      this.centerElement(this.score);
      this.centerElement(this.scoreDiff);
      this.centerElement(this.moves);
      this.centerElement(this.movesDiff);
      return this.getLayer().draw();
    };

    return TopBarWidget;

  })(GrotEngine.Widget);

  Grot.BottomBarWidget = (function(superClass) {
    extend(BottomBarWidget, superClass);

    BottomBarWidget.prototype.label = null;

    BottomBarWidget.prototype.game = null;

    BottomBarWidget.prototype.help = null;

    BottomBarWidget.prototype.menu = null;

    BottomBarWidget.prototype.showPreview = false;

    function BottomBarWidget(config) {
      var imageQuestionMarkObj, logoImgObj, previewHeight;
      BottomBarWidget.__super__.constructor.apply(this, arguments);
      previewHeight = this.showPreview ? cfg.previewHeight : 0;
      this.background = new Kinetic.Rect({
        width: 600,
        height: 120,
        x: 0,
        y: 780 + previewHeight,
        fill: cfg.bodyColor
      });
      this.add(this.background);
      this.buttonHelpGroup = new Kinetic.Group({
        x: 524,
        y: 820 + previewHeight
      });
      this.circleHelp = new Kinetic.Circle({
        x: 20,
        y: 30,
        radius: 40,
        fill: cfg.circleColor4
      });
      this.buttonHelpGroup.add(this.circleHelp);
      imageQuestionMarkObj = new Image();
      imageQuestionMarkObj.onload = (function(_this) {
        return function() {
          _this.imageQuestionMarkHelpLink = new Kinetic.Image({
            x: 2,
            y: 6,
            image: imageQuestionMarkObj,
            width: 40,
            height: 56
          });
          _this.buttonHelpGroup.add(_this.imageQuestionMarkHelpLink);
          return _this.add(_this.buttonHelpGroup);
        };
      })(this);
      imageQuestionMarkObj.src = '/static/images/question-mark-icon.png';
      this.buttonHelpGroup.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return game.renderManager.menuOverlay.fire('showHelp');
        };
      })(this));
      logoImgObj = new Image();
      logoImgObj.onload = (function(_this) {
        return function() {
          _this.hero = new Kinetic.Image({
            x: 208,
            y: 811 + previewHeight,
            image: logoImgObj,
            width: 183,
            height: 71
          });
          _this.add(_this.hero);
          return _this.getLayer().draw();
        };
      })(this);
      logoImgObj.src = '/static/images/logo.png';
      this.buttonMenuGroup = new Kinetic.Group({
        x: 36,
        y: 820 + previewHeight
      });
      this.circleMenu = new Kinetic.Circle({
        x: 20,
        y: 30,
        radius: 40,
        fill: cfg.circleColor4
      });
      this.rectMenu1 = new Kinetic.Rect({
        x: 5,
        y: 10,
        width: 10,
        height: 40,
        fill: cfg.fontMenuColor
      });
      this.rectMenu2 = this.rectMenu1.clone({
        x: 25
      });
      this.buttonMenuGroup.add(this.circleMenu);
      this.buttonMenuGroup.add(this.rectMenu1);
      this.buttonMenuGroup.add(this.rectMenu2);
      this.add(this.buttonMenuGroup);
      this.buttonMenuGroup.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return game.renderManager.menuOverlay.fire('showMenu');
        };
      })(this));
    }

    BottomBarWidget.prototype.centerText = function(text) {
      text.offsetX(text.width() / 2);
      return text.offsetY(text.height() / 2);
    };

    BottomBarWidget.prototype.scale = function(scale) {
      return this.scale({
        x: scale,
        y: scale
      });
    };

    return BottomBarWidget;

  })(GrotEngine.Widget);

  Grot.FieldWidget = (function(superClass) {
    extend(FieldWidget, superClass);

    FieldWidget.prototype.circle = null;

    FieldWidget.prototype.label = null;

    FieldWidget.prototype.field = null;

    FieldWidget.prototype.callback = null;

    FieldWidget.prototype.relativeScale = null;

    FieldWidget.prototype.colors = {
      gray: cfg.circleColor1,
      blue: cfg.circleColor2,
      green: cfg.circleColor3,
      red: cfg.circleColor4
    };

    FieldWidget.prototype.arrows = {
      left: 270,
      right: 90,
      up: 0,
      down: 180,
      none: 0
    };

    function FieldWidget(config) {
      var radius;
      FieldWidget.__super__.constructor.apply(this, arguments);
      if (this.field instanceof Grot.PreviewField) {
        radius = cfg.previewCircleRadius;
        this.arrow = smallArrow.clone();
      } else {
        radius = cfg.circleRadius;
        this.arrow = arrow.clone();
      }
      this.relativeScale = this.field.relativeScale;
      this.circle = new Kinetic.Circle({
        x: 0,
        y: 0,
        radius: radius,
        fill: this.colors[this.field.value],
        transformsEnabled: 'position'
      });
      this.arrow.rotate(this.arrows[this.field.direction]);
      this.add(this.circle);
      this.add(this.arrow);
      this.scale(this.relativeScale);
    }

    FieldWidget.prototype.relativeMove = function(x, y) {
      return this.move({
        x: x - this.x(),
        y: y - this.y()
      });
    };

    FieldWidget.prototype.reset = function() {
      var angle;
      this.circle.fill(this.colors[this.field.value]);
      angle = this.arrows[this.field.direction] - this.arrow.rotation();
      return this.arrow.rotate(angle);
    };

    FieldWidget.prototype.setupCallback = function(callback) {
      var widget;
      this.callback = callback;
      widget = this;
      this.on('forcePress', function(event) {
        return widget.callback(widget.field, event);
      });
      return this.on('mousedown touchstart', function(event) {
        return widget.callback(widget.field, event);
      });
    };

    return FieldWidget;

  })(GrotEngine.Widget);

  Grot.Field = (function() {
    Field.prototype.x = null;

    Field.prototype.y = null;

    Field.prototype.id = null;

    Field.prototype.value = null;

    Field.prototype.direction = null;

    Field.prototype.widget = null;

    Field.prototype.board = null;

    Field.prototype.renderManager = null;

    Field.prototype.relativeScale = null;

    Field.prototype.preview = null;

    Field.prototype.points = {
      gray: 1,
      blue: 2,
      green: 3,
      red: 4
    };

    function Field(board, x1, y1) {
      this.board = board;
      this.x = x1;
      this.y = y1;
      this.id = this.x + "-" + this.y;
      this.renderManager = this.board.renderManager;
      this.relativeScale = this.board.fieldRelativeScale;
      this.preview = this.board.preview;
      this.reset();
      this.widget = new Grot.FieldWidget({
        field: this
      });
    }

    Field.prototype.reset = function() {
      var ref;
      ref = this.preview.pop(), this.value = ref[0], this.direction = ref[1];
      if (this.widget != null) {
        return this.widget.reset();
      }
    };

    Field.prototype.getPoints = function() {
      return this.points[this.value];
    };

    Field.prototype.getFieldCenter = function() {
      var centerX, centerY, fieldSpacing, relativeRadius;
      relativeRadius = cfg.circleRadius * this.relativeScale;
      fieldSpacing = cfg.spaceBetweenFields * this.relativeScale;
      centerX = fieldSpacing + relativeRadius + this.x * (relativeRadius * 2 + fieldSpacing);
      centerY = fieldSpacing + relativeRadius + this.y * (relativeRadius * 2 + fieldSpacing);
      if (this.board.showPreview) {
        centerY += cfg.previewHeight * this.relativeScale;
      }
      return [centerX, centerY];
    };

    Field.prototype.updatePosition = function(x1, y1) {
      this.x = x1;
      this.y = y1;
      return this.id = this.x + "-" + this.y;
    };

    return Field;

  })();

  Grot.PreviewField = (function(superClass) {
    extend(PreviewField, superClass);

    function PreviewField(board, x1) {
      this.board = board;
      this.x = x1;
      this.id = "preview-" + this.x;
      this.renderManager = this.board.renderManager;
      this.relativeScale = this.board.fieldRelativeScale;
      this.randomParams();
      this.widget = new Grot.FieldWidget({
        field: this
      });
    }

    PreviewField.prototype.randomParams = function() {
      var points;
      points = ['gray', 'gray', 'gray', 'gray', 'blue', 'blue', 'blue', 'green', 'green', 'red'];
      this.value = randomChoice(points);
      return this.direction = randomChoice(['left', 'right', 'up', 'down']);
    };

    PreviewField.prototype.getFieldCenter = function() {
      var fieldRadius, fieldSpacing, previewRadius, previewSpacing;
      fieldRadius = cfg.circleRadius * this.relativeScale;
      previewRadius = cfg.previewCircleRadius * this.relativeScale;
      fieldSpacing = cfg.spaceBetweenFields * this.relativeScale;
      previewSpacing = cfg.spaceBetweenPreviewFields * this.relativeScale;
      return [fieldSpacing + previewRadius + this.x * (previewRadius * 2 + previewSpacing), fieldSpacing + previewRadius];
    };

    PreviewField.prototype.updatePosition = function(x1) {
      this.x = x1;
      return this.id = "preview-" + this.x;
    };

    PreviewField.prototype.shift = function() {
      return this.updatePosition(this.x - 1);
    };

    return PreviewField;

  })(Grot.Field);

  Grot.Preview = (function() {
    Preview.prototype.fields = [];

    function Preview(board, size) {
      var x;
      this.board = board;
      this.size = size;
      this.fields = (function() {
        var j, ref, results;
        results = [];
        for (x = j = 0, ref = this.size * 2 - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
          results.push(new Grot.PreviewField(this.board, x));
        }
        return results;
      }).call(this);
    }

    Preview.prototype.pop = function() {
      var field, i, j, len, newField, ref, result;
      field = this.fields.shift();
      result = [field.value, field.direction];
      field.widget.destroy();
      ref = this.fields;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        i.shift();
      }
      newField = new Grot.PreviewField(this.board, this.size * 2 - 1);
      newField.widget.setOpacity(0);
      this.fields.push(newField);
      this.board.add(newField.widget);
      return result;
    };

    return Preview;

  })();

  Grot.Board = (function(superClass) {
    extend(Board, superClass);

    Board.prototype.size = 9;

    Board.prototype.fields = [];

    Board.prototype.preview = null;

    Board.prototype.showPreview = false;

    Board.prototype.fieldRelativeScale = 0;

    Board.prototype.renderManager = null;

    function Board(config) {
      Board.__super__.constructor.apply(this, arguments);
      this.background = new Kinetic.Rect({
        width: config.width,
        height: config.height,
        fill: cfg.bodyColor
      });
      this.add(this.background);
      this.fieldRelativeScale = 4 / this.size;
      this.createPreview();
      this.createBoard();
      this.on('arrowPress', this.handleArrowPress);
    }

    Board.prototype.handleArrowPress = function(arrowPos) {
      var x, y;
      x = arrowPos[0] - 1;
      y = arrowPos[1] - 1;
      if (this.fields[x] && this.fields[x][y]) {
        return this.fields[x][y].widget.fire('forcePress');
      }
    };

    Board.prototype.createBoard = function() {
      var j, ref, results, x, y;
      results = [];
      for (x = j = 0, ref = this.size - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        results.push(this.fields.push((function() {
          var k, ref1, results1;
          results1 = [];
          for (y = k = 0, ref1 = this.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
            results1.push(new Grot.Field(this, x, y));
          }
          return results1;
        }).call(this)));
      }
      return results;
    };

    Board.prototype.createPreview = function() {
      this.preview = new Grot.Preview(this, this.size);
      return this.preview.pop();
    };

    Board.prototype.getNextField = function(field, lastDirection) {
      var direction, nextField;
      if (lastDirection == null) {
        lastDirection = null;
      }
      direction = lastDirection ? lastDirection : field.direction;
      if (direction === 'left') {
        if (field.x === 0) {
          return [field, true];
        }
        nextField = this.fields[field.x - 1][field.y];
      } else if (direction === 'right') {
        if (field.x === (this.size - 1)) {
          return [field, true];
        }
        nextField = this.fields[field.x + 1][field.y];
      } else if (direction === 'up') {
        if (field.y === 0) {
          return [field, true];
        }
        nextField = this.fields[field.x][field.y - 1];
      } else if (direction === 'down') {
        if (field.y === (this.size - 1)) {
          return [field, true];
        }
        nextField = this.fields[field.x][field.y + 1];
      }
      if (nextField.direction === 'none') {
        return this.getNextField(nextField, direction);
      }
      return [nextField, false];
    };

    Board.prototype.lowerField = function(field) {
      var lastMove, newX, newY, nextField, oldX, oldY, ref;
      oldX = field.x;
      oldY = field.y;
      ref = this.getNextField(field, 'down'), nextField = ref[0], lastMove = ref[1];
      newX = nextField.x;
      newY = nextField.y;
      if (!lastMove) {
        newY = nextField.y - 1;
      }
      if (newY === oldY) {
        return [];
      }
      this.fields[oldX][oldY] = this.fields[newX][newY];
      this.fields[oldX][oldY].updatePosition(oldX, oldY);
      this.fields[newX][newY] = field;
      this.fields[newX][newY].updatePosition(newX, newY);
      return [newX, newY];
    };

    return Board;

  })(GrotEngine.Layer);

  Grot.MenuWidget = (function(superClass) {
    extend(MenuWidget, superClass);

    MenuWidget.prototype.group = null;

    MenuWidget.prototype.menuLayer = null;

    MenuWidget.prototype.showPreview = false;

    MenuWidget.prototype.game = null;

    function MenuWidget(config) {
      this.close = bind(this.close, this);
      this.draw = bind(this.draw, this);
      var aboutImageObj, helpImageObj, previewHeight, resetGameImageObj, resumeImageObj, scoreBoardImageObj;
      MenuWidget.__super__.constructor.apply(this, arguments);
      previewHeight = this.showPreview ? cfg.previewHeight : 0;
      this.background = new Kinetic.Rect({
        width: 600,
        height: 900 + previewHeight,
        x: 0,
        y: 0,
        fill: cfg.overlayColor,
        opacity: 0.9
      });
      this.container = new GrotEngine.Widget({
        width: 600,
        height: 900 + previewHeight,
        margins: {
          x: 0,
          y: 0
        },
        layer: this.menuLayer
      });
      this.gameName = new Kinetic.Text({
        x: 235,
        y: 100,
        text: 'GROT',
        align: 'center',
        fontSize: 60,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      this.line = new Kinetic.Rect({
        x: 0,
        y: 200,
        width: 600,
        height: 2,
        fill: cfg.fontMenuColor
      });
      resetGameImageObj = new Image();
      this.resetGameImg = new Kinetic.Image({
        x: 125,
        y: 300,
        image: resetGameImageObj,
        width: 75,
        height: 75
      });
      this.resetGameText = new Kinetic.Text({
        x: 100,
        y: 400,
        text: 'New Game',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      scoreBoardImageObj = new Image();
      this.scoreBoardLinkImg = new Kinetic.Image({
        x: 410,
        y: 300,
        image: scoreBoardImageObj,
        width: 75,
        height: 75
      });
      this.scoreBoardLinkText = new Kinetic.Text({
        x: 385,
        y: 400,
        text: 'High scores',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      helpImageObj = new Image();
      this.helpImage = new Kinetic.Image({
        x: 125,
        y: 550,
        image: helpImageObj,
        width: 75,
        height: 75
      });
      this.helpText = new Kinetic.Text({
        x: 134,
        y: 650,
        text: 'Help',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      aboutImageObj = new Image();
      this.aboutImg = new Kinetic.Image({
        x: 410,
        y: 550,
        image: aboutImageObj,
        width: 75,
        height: 75
      });
      this.aboutText = new Kinetic.Text({
        x: 412,
        y: 650,
        text: 'About',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      resumeImageObj = new Image();
      this.resumeImg = new Kinetic.Image({
        x: 265,
        y: 740,
        image: resumeImageObj,
        width: 75,
        height: 75
      });
      this.resumeText = new Kinetic.Text({
        x: 258,
        y: 820,
        text: 'Resume',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      resetGameImageObj.src = '/static/images/menu-new-game-icon.png';
      scoreBoardImageObj.src = '/static/images/menu-high-score-icon.png';
      helpImageObj.src = '/static/images/menu-help-icon.png';
      aboutImageObj.src = '/static/images/menu-about-icon.png';
      resumeImageObj.src = '/static/images/menu-resume-icon.png';
      this.resetGameImg.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return window.location.replace(window.location.href);
        };
      })(this));
      this.resetGameText.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return window.location.replace(window.location.href);
        };
      })(this));
      this.scoreBoardLinkImg.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return window.location.replace(cfg.scoreBoardLink);
        };
      })(this));
      this.scoreBoardLinkText.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return window.location.replace(cfg.scoreBoardLink);
        };
      })(this));
      this.helpImage.on('mousedown touchstart', (function(_this) {
        return function(event) {
          _this.fire('menuRemove');
          return _this.menuLayer.fire('showHelp');
        };
      })(this));
      this.helpText.on('mousedown touchstart', (function(_this) {
        return function(event) {
          _this.fire('menuRemove');
          return _this.menuLayer.fire('showHelp');
        };
      })(this));
      this.aboutImg.on('mousedown touchstart', (function(_this) {
        return function(event) {
          _this.fire('menuRemove');
          return _this.menuLayer.fire('showAbout');
        };
      })(this));
      this.aboutText.on('mousedown touchstart', (function(_this) {
        return function(event) {
          _this.fire('menuRemove');
          return _this.menuLayer.fire('showAbout');
        };
      })(this));
      this.resumeImg.on('mousedown touchstart', this.close);
      this.resumeText.on('mousedown touchstart', this.close);
      this.on('menuDraw', this.draw);
      this.on('menuRemove', this.close);
      this.fire('update');
    }

    MenuWidget.prototype.updateHandler = function() {
      if (this.menuLayer.parent) {
        return this.container.fire('update');
      }
    };

    MenuWidget.prototype.draw = function() {
      this.add(this.background);
      this.add(this.container);
      this.container.add(this.gameName);
      this.container.add(this.line);
      this.container.add(this.resetGameImg);
      this.container.add(this.resetGameText);
      this.container.add(this.scoreBoardLinkImg);
      this.container.add(this.scoreBoardLinkText);
      this.container.add(this.helpImage);
      this.container.add(this.helpText);
      this.container.add(this.aboutImg);
      this.container.add(this.aboutText);
      this.container.add(this.resumeImg);
      this.container.add(this.resumeText);
      return this.getLayer().draw();
    };

    MenuWidget.prototype.close = function() {
      this.removeChildren();
      return this.menuLayer.fire('closeMenuOverlay');
    };

    return MenuWidget;

  })(GrotEngine.Widget);

  Grot.GameOverWidget = (function(superClass) {
    extend(GameOverWidget, superClass);

    GameOverWidget.prototype.game = null;

    GameOverWidget.prototype.menuLayer = null;

    GameOverWidget.prototype.showPreview = null;

    function GameOverWidget(config) {
      this.close = bind(this.close, this);
      this.draw = bind(this.draw, this);
      var previewHeight, resetGameImageObj, scoreBoardImageObj;
      GameOverWidget.__super__.constructor.apply(this, arguments);
      previewHeight = this.showPreview ? cfg.previewHeight : 0;
      this.background = new Kinetic.Rect({
        width: 600,
        height: 900 + previewHeight,
        x: 0,
        y: 0,
        fill: cfg.overlayColor,
        opacity: 0.9
      });
      this.container = new GrotEngine.Widget({
        width: 600,
        height: 900 + previewHeight,
        margins: {
          x: 0,
          y: 0
        },
        layer: this.menuLayer
      });
      this.line = new Kinetic.Rect({
        x: 0,
        y: 200,
        width: 600,
        height: 2,
        fill: cfg.fontMenuColor
      });
      this.gameOverMsg = new Kinetic.Text({
        x: 320,
        y: 125,
        text: 'Game Over',
        align: 'center',
        fontSize: 60,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      this.yourScoreMsg = new Kinetic.Text({
        x: 315,
        y: 300,
        text: 'Your Score:',
        align: 'center',
        fontSize: 40,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      this.scoreResult = new Kinetic.Text({
        x: 300,
        y: 350,
        text: '',
        align: 'center',
        fontSize: 35,
        fontfamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: '#00BFFF'
      });
      resetGameImageObj = new Image();
      this.resetGameImg = new Kinetic.Image({
        x: 135,
        y: 500,
        image: resetGameImageObj,
        width: 75,
        height: 75
      });
      this.resetGameText = new Kinetic.Text({
        x: 180,
        y: 610,
        text: 'New Game',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      scoreBoardImageObj = new Image();
      this.scoreBoardLinkImg = new Kinetic.Image({
        x: 410,
        y: 500,
        image: scoreBoardImageObj,
        width: 75,
        height: 75
      });
      this.scoreBoardLinkText = new Kinetic.Text({
        x: 455,
        y: 610,
        text: 'High scores',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      resetGameImageObj.src = '/static/images/menu-new-game-icon.png';
      scoreBoardImageObj.src = '/static/images/menu-high-score-icon.png';
      this.resetGameImg.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return window.location.replace(window.location.href);
        };
      })(this));
      this.resetGameText.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return window.location.replace(window.location.href);
        };
      })(this));
      this.scoreBoardLinkImg.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return window.location.replace(cfg.scoreBoardLink);
        };
      })(this));
      this.scoreBoardLinkText.on('mousedown touchstart', (function(_this) {
        return function(event) {
          return window.location.replace(cfg.scoreBoardLink);
        };
      })(this));
      this.centerElement(this.gameOverMsg);
      this.centerElement(this.yourScoreMsg);
      this.centerElement(this.resetGameText);
      this.centerElement(this.scoreBoardLinkText);
      this.on('gameOverDraw', this.draw);
      this.on('gameOverRemove', this.close);
    }

    GameOverWidget.prototype.updateHandler = function() {
      if (this.menuLayer.parent) {
        return this.container.fire('update');
      }
    };

    GameOverWidget.prototype.draw = function(score) {
      this.scoreResult.setText(score);
      this.centerElement(this.scoreResult);
      this.add(this.background);
      this.add(this.container);
      this.container.add(this.gameOverMsg);
      this.container.add(this.line);
      this.container.add(this.yourScoreMsg);
      this.container.add(this.scoreResult);
      this.container.add(this.resetGameImg);
      this.container.add(this.resetGameText);
      this.container.add(this.scoreBoardLinkImg);
      this.container.add(this.scoreBoardLinkText);
      return this.getLayer().draw();
    };

    GameOverWidget.prototype.close = function() {
      this.removeChildren();
      return this.menuLayer.fire('closeMenuOverlay');
    };

    return GameOverWidget;

  })(GrotEngine.Widget);

  Grot.HelpWidget = (function(superClass) {
    extend(HelpWidget, superClass);

    HelpWidget.prototype.game = null;

    HelpWidget.prototype.menuLayer = null;

    HelpWidget.prototype.showPreview = false;

    function HelpWidget(config) {
      this.close = bind(this.close, this);
      this.draw = bind(this.draw, this);
      var previewHeight, resumeImageObj;
      HelpWidget.__super__.constructor.apply(this, arguments);
      previewHeight = this.showPreview ? cfg.previewHeight : 0;
      this.background = new Kinetic.Rect({
        width: 600,
        height: 900 + previewHeight,
        x: 0,
        y: 0,
        fill: cfg.overlayColor,
        opacity: 0.9
      });
      this.container = new GrotEngine.Widget({
        width: 600,
        height: 900 + previewHeight,
        margins: {
          x: 0,
          y: 0
        },
        layer: this.menuLayer
      });
      this.appName = new Kinetic.Text({
        x: 10,
        y: 50,
        fontSize: 60,
        fontFamily: cfg.fontFamily,
        text: 'GROT',
        fill: cfg.fontMenuColor
      });
      this.engAppName = this.appName.clone({
        y: 110,
        x: 10,
        fontSize: 36,
        text: '(eng. Arrowhead)'
      });
      this.description = this.appName.clone({
        y: 180,
        x: 10,
        width: 580,
        fontSize: 26,
        text: cfg.helpDesc
      });
      this.points = this.appName.clone({
        y: 550,
        x: 25,
        fontSize: 30,
        text: 'Points:'
      });
      this.pointsVisualisation = new GrotEngine.Widget({
        width: 580,
        height: 42,
        x: 10,
        y: 600
      });
      this.circle1 = new Kinetic.Circle({
        x: 50,
        y: 50,
        radius: 40,
        fill: cfg.circleColor1
      });
      this.circlePoints1 = new Kinetic.Text({
        x: 100,
        y: 35,
        text: 'x1',
        fill: cfg.fontMenuColor,
        fontSize: 30,
        fontFamily: cfg.fontFamily
      });
      this.circle2 = this.circle1.clone({
        x: 190,
        fill: cfg.circleColor2
      });
      this.circlePoints2 = this.circlePoints1.clone({
        x: 240,
        text: 'x2'
      });
      this.circle3 = this.circle1.clone({
        x: 330,
        fill: cfg.circleColor3
      });
      this.circlePoints3 = this.circlePoints1.clone({
        x: 380,
        text: 'x3'
      });
      this.circle4 = this.circle1.clone({
        x: 470,
        fill: cfg.circleColor4
      });
      this.circlePoints4 = this.circlePoints1.clone({
        x: 520,
        text: 'x4'
      });
      resumeImageObj = new Image();
      this.resumeImg = new Kinetic.Image({
        x: 265,
        y: 740,
        image: resumeImageObj,
        width: 75,
        height: 75
      });
      this.resumeText = new Kinetic.Text({
        x: 258,
        y: 820,
        text: 'Resume',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      resumeImageObj.src = '/static/images/menu-resume-icon.png';
      this.resumeImg.on('mousedown touchstart', this.close);
      this.resumeText.on('mousedown touchstart', this.close);
      this.on('helpDraw', this.draw);
      this.on('helpRemove', this.close);
      this.fire('update');
    }

    HelpWidget.prototype.updateHandler = function() {
      if (this.menuLayer.parent) {
        return this.container.fire('update');
      }
    };

    HelpWidget.prototype.draw = function() {
      this.add(this.background);
      this.add(this.container);
      this.container.add(this.appName);
      this.container.add(this.engAppName);
      this.container.add(this.description);
      this.container.add(this.points);
      this.container.add(this.pointsVisualisation);
      this.pointsVisualisation.add(this.circle1);
      this.pointsVisualisation.add(this.circlePoints1);
      this.pointsVisualisation.add(this.circle2);
      this.pointsVisualisation.add(this.circlePoints2);
      this.pointsVisualisation.add(this.circle3);
      this.pointsVisualisation.add(this.circlePoints3);
      this.pointsVisualisation.add(this.circle4);
      this.pointsVisualisation.add(this.circlePoints4);
      this.container.add(this.resumeImg);
      this.container.add(this.resumeText);
      return this.getLayer().draw();
    };

    HelpWidget.prototype.close = function() {
      this.removeChildren();
      return this.menuLayer.fire('closeMenuOverlay');
    };

    return HelpWidget;

  })(GrotEngine.Widget);

  Grot.AboutWidget = (function(superClass) {
    extend(AboutWidget, superClass);

    AboutWidget.prototype.game = null;

    AboutWidget.prototype.menuLayer = null;

    AboutWidget.prototype.showPreview = false;

    function AboutWidget(config) {
      this.close = bind(this.close, this);
      this.draw = bind(this.draw, this);
      var previewHeight, resumeImageObj;
      AboutWidget.__super__.constructor.apply(this, arguments);
      previewHeight = this.showPreview ? cfg.previewHeight : 0;
      this.background = new Kinetic.Rect({
        width: 600,
        height: 900 + previewHeight,
        x: 0,
        y: 0,
        fill: cfg.overlayColor,
        opacity: 0.9
      });
      this.container = new GrotEngine.Widget({
        width: 600,
        height: 900 + previewHeight,
        margins: {
          x: 0,
          y: 0
        },
        layer: this.menuLayer
      });
      this.appName = new Kinetic.Text({
        x: 10,
        y: 50,
        fontSize: 60,
        fontFamily: cfg.fontFamily,
        text: 'GROT',
        fill: cfg.fontMenuColor
      });
      this.appVer = this.appName.clone({
        y: 110,
        x: 10,
        fontSize: 36,
        text: cfg.aboutVer
      });
      this.description = this.appName.clone({
        y: 180,
        x: 10,
        width: 580,
        fontSize: 26,
        text: cfg.aboutDesc
      });
      resumeImageObj = new Image();
      this.resumeImg = new Kinetic.Image({
        x: 265,
        y: 740,
        image: resumeImageObj,
        width: 75,
        height: 75
      });
      this.resumeText = new Kinetic.Text({
        x: 258,
        y: 820,
        text: 'Resume',
        align: 'center',
        fontSize: 25,
        fontFamily: cfg.fontFamily,
        fontStyle: cfg.fontStyle,
        fill: cfg.fontMenuColor
      });
      resumeImageObj.src = '/static/images/menu-resume-icon.png';
      this.resumeImg.on('mousedown touchstart', this.close);
      this.resumeText.on('mousedown touchstart', this.close);
      this.on('aboutDraw', this.draw);
      this.on('aboutRemove', this.close);
      this.fire('update');
    }

    AboutWidget.prototype.updateHandler = function() {
      if (this.menuLayer.parent) {
        return this.container.fire('update');
      }
    };

    AboutWidget.prototype.draw = function() {
      this.add(this.background);
      this.add(this.container);
      this.container.add(this.appName);
      this.container.add(this.appVer);
      this.container.add(this.description);
      this.container.add(this.resumeImg);
      this.container.add(this.resumeText);
      return this.getLayer().draw();
    };

    AboutWidget.prototype.close = function() {
      this.removeChildren();
      return this.menuLayer.fire('closeMenuOverlay');
    };

    return AboutWidget;

  })(GrotEngine.Widget);

  Grot.MenuOverlay = (function(superClass) {
    extend(MenuOverlay, superClass);

    MenuOverlay.prototype.showPreview = false;

    MenuOverlay.prototype.renderManager = null;

    function MenuOverlay() {
      MenuOverlay.__super__.constructor.apply(this, arguments);
      this.gameOverWidget = new Grot.GameOverWidget({
        menuLayer: this,
        showPreview: this.showPreview
      });
      this.menuWidget = new Grot.MenuWidget({
        menuLayer: this,
        showPreview: this.showPreview
      });
      this.helpWidget = new Grot.HelpWidget({
        menuLayer: this,
        showPreview: this.showPreview
      });
      this.aboutWidget = new Grot.AboutWidget({
        menuLayer: this,
        showPreview: this.showPreview
      });
      this.on('showGameOver', this.gameOverWidgetDraw);
      this.on('showMenu', this.menuWidgetDraw);
      this.on('showHelp', this.helpWidgetDraw);
      this.on('showAbout', this.aboutWidgetDraw);
      this.on('closeMenuOverlay', this.closeMenuOverlay);
      this.on('onOverlayOpen', this.onOverlayOpen);
    }

    MenuOverlay.prototype.closeMenuOverlay = function() {
      this.renderManager.stage.fire('normalizeBoardStuff');
      document.body.style.backgroundColor = cfg.bodyColor;
      this.removeChildren;
      return this.draw();
    };

    MenuOverlay.prototype.onOverlayOpen = function() {
      this.renderManager.stage.fire('blurBoardStuff');
      return document.body.style.backgroundColor = cfg.overlayBodyColor;
    };

    MenuOverlay.prototype.updateHandler = function() {
      MenuOverlay.__super__.updateHandler.apply(this, arguments);
      this.gameOverWidget.fire('update');
      this.menuWidget.fire('update');
      this.helpWidget.fire('update');
      return this.aboutWidget.fire('update');
    };

    MenuOverlay.prototype.gameOverWidgetDraw = function(score) {
      this.fire('onOverlayOpen');
      this.add(this.gameOverWidget);
      return this.gameOverWidget.fire('gameOverDraw', score);
    };

    MenuOverlay.prototype.menuWidgetDraw = function() {
      this.fire('onOverlayOpen');
      this.add(this.menuWidget);
      return this.menuWidget.fire('menuDraw');
    };

    MenuOverlay.prototype.helpWidgetDraw = function() {
      this.fire('onOverlayOpen');
      this.add(this.helpWidget);
      return this.helpWidget.fire('helpDraw');
    };

    MenuOverlay.prototype.aboutWidgetDraw = function() {
      this.fire('onOverlayOpen');
      this.add(this.aboutWidget);
      return this.aboutWidget.fire('aboutDraw');
    };

    return MenuOverlay;

  })(GrotEngine.Layer);

  window.TWEEN_DURATION = (10 - cfg.defaultSpeed) * cfg.tweenDurationUnit;

  window.delay1s = function(func) {
    return setTimeout(func, 1000);
  };

  window.randomChoice = function(values) {
    return values[Math.floor(Math.random() * values.length)];
  };

  QueryString = (function() {
    function QueryString(queryString) {
      var key, pair, ref, value;
      this.queryString = queryString;
      this.queryString || (this.queryString = (ref = window.document.location.search) != null ? ref.substr(1) : void 0);
      this.variables = this.queryString.split('&');
      this.pairs = (function() {
        var j, len, ref1, ref2, results;
        ref1 = this.variables;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          pair = ref1[j];
          results.push((ref2 = pair.split('='), key = ref2[0], value = ref2[1], ref2));
        }
        return results;
      }).call(this);
    }

    QueryString.prototype.get = function(name) {
      var j, key, len, ref, ref1, value;
      ref = this.pairs;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], key = ref1[0], value = ref1[1];
        if (key === name) {
          return value;
        }
      }
    };

    return QueryString;

  })();

  RenderManager = (function(superClass) {
    extend(RenderManager, superClass);

    RenderManager.prototype.board = null;

    RenderManager.prototype.stage = null;

    RenderManager.prototype.barsLayer = null;

    RenderManager.prototype.animLayer = null;

    RenderManager.prototype.game = null;

    RenderManager.prototype.topBarWidget = null;

    RenderManager.prototype.menuOverlay = null;

    function RenderManager(boardSize1, showPreview1, game1) {
      var height, j, layer, layers, len, ref, width;
      this.boardSize = boardSize1;
      this.showPreview = showPreview1;
      this.game = game1;
      this.startMove = bind(this.startMove, this);
      ref = this.getWindowSize(), width = ref[0], height = ref[1];
      this.currentScale = this.calculateScaleUnit();
      this.addLayers();
      this.addWidgets();
      this.stage = new Kinetic.Stage({
        container: 'wrap',
        width: width,
        height: height - 4
      });
      this.stage.on('onStageUpdated', this.onStageUpdated.bind(this));
      this.stage.on('blurBoardStuff', this.blurBoardStuff.bind(this));
      this.stage.on('normalizeBoardStuff', this.normalizeBoardStuff.bind(this));
      this.stage.fire('onStageUpdated');
      this.stage.add(this.board);
      this.stage.add(this.barsLayer);
      this.stage.add(this.animLayer);
      this.stage.add(this.menuOverlay);
      this.barsLayer.filters([Kinetic.Filters.Blur]);
      this.board.filters([Kinetic.Filters.Blur]);
      RenderManager.__super__.constructor.apply(this, arguments);
      layers = this.stage.getLayers();
      for (j = 0, len = layers.length; j < len; j++) {
        layer = layers[j];
        layer.fire('update');
      }
      this.stage.fire('ready');
    }

    RenderManager.prototype.addLayers = function() {
      var previewHeight;
      previewHeight = this.showPreview ? cfg.previewHeight : 0;
      this.barsLayer = new GrotEngine.Layer({
        width: 600,
        height: 900 + previewHeight,
        margins: {
          x: 0,
          y: 0
        },
        renderManager: this
      });
      this.board = new Grot.Board({
        size: this.boardSize,
        showPreview: this.showPreview,
        renderManager: this,
        margins: {
          x: 0,
          y: 180
        },
        width: 600,
        height: 600 + previewHeight
      });
      this.game.board = this.board;
      this.animLayer = new GrotEngine.Layer({
        hitGraphEnabled: false,
        margins: {
          x: 0,
          y: 180
        },
        width: 600,
        height: 600 + previewHeight,
        renderManager: this
      });
      return this.menuOverlay = new Grot.MenuOverlay({
        width: 600,
        height: 900 + previewHeight,
        margins: {
          x: 0,
          y: 0
        },
        renderManager: this,
        showPreview: this.showPreview
      });
    };

    RenderManager.prototype.addWidgets = function() {
      var j, k, l, ref, ref1, ref2, x, y;
      this.topBarWidget = new Grot.TopBarWidget({
        game: this.game,
        showPreview: this.showPreview
      });
      this.bottomBarWidget = new Grot.BottomBarWidget({
        game: this.game,
        showPreview: this.showPreview
      });
      for (x = j = 0, ref = this.board.size - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.board.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          this.board.add(this.board.fields[x][y].widget);
        }
      }
      if (this.showPreview) {
        for (x = l = 0, ref2 = this.board.size * 2 - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; x = 0 <= ref2 ? ++l : --l) {
          this.board.preview.fields[x].widget.setOpacity(1);
          this.board.add(this.board.preview.fields[x].widget);
        }
      }
      this.barsLayer.add(this.topBarWidget);
      return this.barsLayer.add(this.bottomBarWidget);
    };

    RenderManager.prototype.normalizeBoardStuff = function() {
      this.barsLayer.blurRadius(0);
      this.board.blurRadius(0);
      this.board.clearCache();
      this.barsLayer.clearCache();
      this.barsLayer.batchDraw();
      return this.board.batchDraw();
    };

    RenderManager.prototype.blurBoardStuff = function() {
      this.barsLayer.cache();
      this.board.cache();
      this.barsLayer.blurRadius(10);
      this.board.blurRadius(10);
      this.barsLayer.batchDraw();
      return this.board.batchDraw();
    };

    RenderManager.prototype.moveFieldToLayer = function(field, toLayer) {
      var fromLayer;
      fromLayer = field.widget.getLayer();
      field.widget.moveTo(toLayer);
      fromLayer.draw();
      return toLayer.draw();
    };

    RenderManager.prototype.onStageUpdated = function() {
      var centerX, centerY, field, j, k, l, ref, ref1, ref2, ref3, ref4, results, widget, x, y;
      for (x = j = 0, ref = this.board.size - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.board.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          field = this.board.fields[x][y];
          ref2 = field.getFieldCenter(), centerX = ref2[0], centerY = ref2[1];
          widget = field.widget;
          widget.relativeMove(centerX, centerY);
          if (widget.callback == null) {
            widget.setupCallback(this.startMove);
          }
        }
      }
      if (this.showPreview) {
        results = [];
        for (x = l = 0, ref3 = this.board.size * 2 - 1; 0 <= ref3 ? l <= ref3 : l >= ref3; x = 0 <= ref3 ? ++l : --l) {
          field = this.board.preview.fields[x];
          ref4 = field.getFieldCenter(), centerX = ref4[0], centerY = ref4[1];
          widget = field.widget;
          results.push(widget.relativeMove(centerX, centerY));
        }
        return results;
      }
    };

    RenderManager.prototype.listening = function(state) {
      var j, k, ref, ref1, x, y;
      for (x = j = 0, ref = this.board.size - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.board.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          this.board.fields[x][y].widget.listening(state);
        }
      }
      return this.board.drawHit();
    };

    RenderManager.prototype.startMove = function(field, event) {
      this.listening(false);
      this.game.moves -= 1;
      this.game.scoreDiff = 0;
      this.game.movesDiff = 0;
      this.topBarWidget.update();
      this.movePoints = 0;
      this.moveLength = 0;
      return this.moveToNextField(field);
    };

    RenderManager.prototype.moveToNextField = function(startField) {
      var centerX, centerY, lastMove, nextField, ref, ref1, tween;
      ref = this.board.getNextField(startField), nextField = ref[0], lastMove = ref[1];
      ref1 = nextField.getFieldCenter(), centerX = ref1[0], centerY = ref1[1];
      startField.direction = 'none';
      this.movePoints += startField.getPoints();
      this.moveLength += 1;
      this.moveFieldToLayer(startField, this.animLayer);
      tween = new Kinetic.Tween({
        node: startField.widget,
        duration: window.TWEEN_DURATION,
        x: centerX,
        y: centerY,
        opacity: 0,
        onFinish: (function(_this) {
          return function() {
            if (lastMove) {
              _this.checkEmptyLines();
            } else {
              _this.moveToNextField(nextField);
            }
            return this.destroy();
          };
        })(this)
      });
      return tween.play();
    };

    RenderManager.prototype.checkEmptyLines = function() {
      var isEmptyColumn, isEmptyRow, j, k, l, m, ref, ref1, ref2, ref3, x, y;
      for (x = j = 0, ref = this.board.size - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        isEmptyColumn = true;
        for (y = k = 0, ref1 = this.board.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          if (this.board.fields[x][y].direction !== 'none') {
            isEmptyColumn = false;
          }
        }
        if (isEmptyColumn) {
          this.movePoints += this.board.size * 10;
        }
      }
      for (y = l = 0, ref2 = this.board.size - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; y = 0 <= ref2 ? ++l : --l) {
        isEmptyRow = true;
        for (x = m = 0, ref3 = this.board.size - 1; 0 <= ref3 ? m <= ref3 : m >= ref3; x = 0 <= ref3 ? ++m : --m) {
          if (this.board.fields[x][y].direction !== 'none') {
            isEmptyRow = false;
          }
        }
        if (isEmptyRow) {
          this.movePoints += this.board.size * 10;
        }
      }
      return this.lowerFields();
    };

    RenderManager.prototype.lowerFields = function() {
      var centerX, centerY, field, j, k, l, len, newX, newY, ref, ref1, ref2, result, results, tween, tweens, x, y;
      tweens = [];
      for (y = j = ref = this.board.size - 2; ref <= 0 ? j <= 0 : j >= 0; y = ref <= 0 ? ++j : --j) {
        for (x = k = 0, ref1 = this.board.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; x = 0 <= ref1 ? ++k : --k) {
          field = this.board.fields[x][y];
          if (field.direction !== 'none') {
            result = this.board.lowerField(field);
            if (result.length === 2) {
              newX = result[0], newY = result[1];
              ref2 = field.getFieldCenter(), centerX = ref2[0], centerY = ref2[1];
              this.moveFieldToLayer(field, this.animLayer);
              tweens.push(new Kinetic.Tween({
                node: field.widget,
                easing: Kinetic.Easings.BounceEaseOut,
                duration: window.TWEEN_DURATION,
                x: centerX,
                y: centerY,
                onFinish: (function(_this) {
                  return function() {
                    return this.destroy();
                  };
                })(this)
              }));
            }
          }
        }
      }
      if (tweens.length > 0) {
        tweens[0].onFinish = (function(_this) {
          return function() {
            if (_this.showPreview) {
              _this.movePreviewToEmptyFields();
            } else {
              _this.fillEmptyFields();
            }
            return this.destroy();
          };
        })(this);
        results = [];
        for (l = 0, len = tweens.length; l < len; l++) {
          tween = tweens[l];
          results.push(tween.play());
        }
        return results;
      } else {
        if (this.showPreview) {
          return this.movePreviewToEmptyFields();
        } else {
          return this.fillEmptyFields();
        }
      }
    };

    RenderManager.prototype.fillEmptyFields = function() {
      var field, j, k, l, len, ref, ref1, results, tween, tweens, x, y;
      tweens = [];
      for (x = j = 0, ref = this.board.size - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.board.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          field = this.board.fields[x][y];
          if (field.direction === 'none') {
            field.reset();
            this.moveFieldToLayer(field, this.animLayer);
            tweens.push(new Kinetic.Tween({
              node: field.widget,
              opacity: 1,
              duration: window.TWEEN_DURATION,
              onFinish: (function(_this) {
                return function() {
                  return this.destroy();
                };
              })(this)
            }));
          }
        }
      }
      this.stage.fire('onStageUpdated');
      if (tweens.length > 0) {
        tweens[0].onFinish = (function(_this) {
          return function() {
            _this.finishMove();
            return this.destroy();
          };
        })(this);
        results = [];
        for (l = 0, len = tweens.length; l < len; l++) {
          tween = tweens[l];
          results.push(tween.play());
        }
        return results;
      } else {
        return this.finishMove();
      }
    };

    RenderManager.prototype.movePreviewToEmptyFields = function() {
      var centerX, centerY, destinationField, field, j, k, l, len, m, previewField, previewIndex, ref, ref1, ref2, ref3, ref4, ref5, results, tween, tweens, x, y;
      tweens = [];
      previewIndex = 0;
      for (x = j = 0, ref = this.board.size - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.board.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          field = this.board.fields[x][y];
          if (field.direction === 'none') {
            ref2 = field.getFieldCenter(), centerX = ref2[0], centerY = ref2[1];
            previewField = this.board.preview.fields[previewIndex];
            previewIndex += 1;
            if (previewField != null) {
              this.moveFieldToLayer(previewField, this.animLayer);
              tweens.push(new Kinetic.Tween({
                node: previewField.widget,
                x: centerX,
                y: centerY,
                scaleX: 2,
                scaleY: 2,
                duration: window.TWEEN_DURATION,
                onFinish: (function(_this) {
                  return function() {
                    return this.destroy();
                  };
                })(this)
              }));
            }
          }
        }
      }
      if (previewIndex < this.board.size * 2 - 1) {
        for (x = l = ref3 = previewIndex, ref4 = this.board.size * 2 - 1; ref3 <= ref4 ? l <= ref4 : l >= ref4; x = ref3 <= ref4 ? ++l : --l) {
          previewField = this.board.preview.fields[x];
          destinationField = this.board.preview.fields[x - previewIndex];
          ref5 = destinationField.getFieldCenter(), centerX = ref5[0], centerY = ref5[1];
          this.moveFieldToLayer(previewField, this.animLayer);
          tweens.push(new Kinetic.Tween({
            node: previewField.widget,
            x: centerX,
            y: centerY,
            duration: window.TWEEN_DURATION,
            onFinish: (function(_this) {
              return function() {
                return this.destroy();
              };
            })(this)
          }));
        }
      }
      if (tweens.length > 0) {
        tweens[0].onFinish = (function(_this) {
          return function() {
            _this.updatePreview();
            return this.destroy();
          };
        })(this);
        results = [];
        for (m = 0, len = tweens.length; m < len; m++) {
          tween = tweens[m];
          results.push(tween.play());
        }
        return results;
      } else {
        return this.updatePreview();
      }
    };

    RenderManager.prototype.updatePreview = function() {
      var field, j, k, l, len, m, previewField, ref, ref1, ref2, results, tween, tweens, x, y;
      tweens = [];
      for (x = j = 0, ref = this.board.size - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.board.size - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          field = this.board.fields[x][y];
          if (field.direction === 'none') {
            field.reset();
            field.widget.setOpacity(1);
          }
        }
      }
      this.stage.fire('onStageUpdated');
      for (x = l = 0, ref2 = this.board.size * 2 - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; x = 0 <= ref2 ? ++l : --l) {
        previewField = this.board.preview.fields[x];
        if (previewField.widget.getOpacity() === 0) {
          tweens.push(new Kinetic.Tween({
            node: previewField.widget,
            opacity: 1,
            duration: window.TWEEN_DURATION,
            onFinish: (function(_this) {
              return function() {
                return this.destroy();
              };
            })(this)
          }));
        }
      }
      if (tweens.length > 0) {
        tweens[0].onFinish = (function(_this) {
          return function() {
            _this.finishMove();
            return this.destroy();
          };
        })(this);
        results = [];
        for (m = 0, len = tweens.length; m < len; m++) {
          tween = tweens[m];
          results.push(tween.play());
        }
        return results;
      } else {
        return this.finishMove();
      }
    };

    RenderManager.prototype.gameOver = function() {
      this.menuOverlay.fire('showGameOver', this.game.score);
      return this.stage.fire('gameOver');
    };

    RenderManager.prototype.finishMove = function() {
      var attrs, field, fields, j, len, multiplier;
      this.game.score += this.movePoints;
      this.game.scoreDiff = this.movePoints;
      multiplier = 100 / (this.game.score + 200);
      this.game.movesDiff = Math.floor(this.moveLength * multiplier);
      this.game.moves += this.game.movesDiff;
      this.topBarWidget.update();
      fields = (function() {
        var j, len, ref, results;
        ref = this.animLayer.children;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          attrs = ref[j];
          results.push(attrs.field);
        }
        return results;
      }).call(this);
      for (j = 0, len = fields.length; j < len; j++) {
        field = fields[j];
        this.moveFieldToLayer(field, this.board);
      }
      if (this.game.moves > 0) {
        this.listening(true);
        return this.stage.fire('moveCompleted');
      } else {
        this.stage.fire('moveCompleted');
        return this.gameOver(this.game);
      }
    };

    return RenderManager;

  })(GrotEngine.RenderManager);

  Game = (function(superClass) {
    extend(Game, superClass);

    Game.prototype.board = null;

    Game.prototype.score = 0;

    Game.prototype.scoreDiff = 0;

    Game.prototype.moves = 5;

    Game.prototype.movesDiff = 0;

    Game.prototype.renderManager = null;

    function Game() {
      var boardSize, qs, qsPreview, qsSize, qsSpeed, showPreview, speed;
      Game.__super__.constructor.apply(this, arguments);
      qs = new QueryString;
      qsSize = parseInt(qs.get('size'));
      qsPreview = qs.get('preview') === 'true';
      qsSpeed = parseInt(qs.get('speed'));
      boardSize = cfg.customBoardSize && qsSize ? qsSize : cfg.defaultBoardSize;
      showPreview = cfg.customShowPreview && qsPreview ? qsPreview : cfg.showPreview;
      speed = cfg.customSpeed && qsSpeed && qsSpeed > 0 && qsSpeed < 10 ? qsSpeed : cfg.defaultSpeed;
      window.TWEEN_DURATION = (10 - speed) * cfg.tweenDurationUnit;
      this.renderManager = new RenderManager(boardSize, showPreview, this);
    }

    return Game;

  })(GrotEngine.Game);

  document.body.style.cssText = 'background-color: ' + cfg.bodyColor + '; margin: 0; padding: 0;';

  window.game = game = new Game();

}).call(this);
